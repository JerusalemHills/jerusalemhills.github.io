<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Shooter - Colorful Bubble Popping Game | Jerusalem Hills Games</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Pop colorful bubbles in this classic bubble shooter game! Aim, shoot, and match 3 or more bubbles to clear the board. Addictive puzzle gameplay with power-ups.">
    <meta name="keywords" content="bubble shooter, bubble game, bubble pop, puzzle game, arcade game, matching game">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://jerusalemhills.com/games/bubble-shooter/bubble-shooter.html">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Bubble Shooter - Colorful Bubble Popping Game">
    <meta property="og:description" content="Pop colorful bubbles in this classic bubble shooter game! Aim, shoot, and match bubbles to clear the board.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://jerusalemhills.com/games/bubble-shooter/bubble-shooter.html">
    
    <!-- Google Analytics -->
    <script src="/js/analytics.js"></script>
    
    <!-- Game Progression System -->
    <script src="/js/game-progression.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
            position: relative;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-item {
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .btn.secondary {
            background: linear-gradient(145deg, #6c757d, #5a6268);
        }
        
        .game-container {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
        }
        
        .game-canvas {
            width: 100%;
            max-width: 500px;
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            border-radius: 15px;
            border: 3px solid white;
            margin: 0 auto;
            display: block;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
            cursor: crosshair;
        }
        
        .shooter-area {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .shooter-bubble {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .next-bubble {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .aiming-line {
            position: absolute;
            width: 2px;
            background: rgba(255,255,255,0.7);
            transform-origin: bottom center;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }
        
        .back-button:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        
        .message {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .message.success {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 2px solid #4CAF50;
        }
        
        .message.info {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
            border: 2px solid #2196F3;
        }
        
        .message.warning {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
            border: 2px solid #FF9800;
        }
        
        .win-celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .win-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }
        
        .win-content h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        
        .bubble-colors {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        @media (max-width: 768px) {
            .game-canvas {
                height: 500px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .control-item {
                padding: 8px 15px;
                font-size: 14px;
            }
            
            .shooter-area {
                width: 70px;
                height: 70px;
            }
            
            .shooter-bubble {
                width: 50px;
                height: 50px;
                font-size: 1.2em;
            }
        }
    </style>

    <!-- Mobile Touch Controls -->
    <script src="/js/mobile-touch-controls.js"></script>

    <!-- Accessibility Enhancements -->
    <script src="/js/accessibility-enhancements.js"></script>
</head>
<body>
    <button class="back-button" onclick="window.location.href='/games/'" aria-label="Back to Games" title="Back to Games">‚Üê</button>
    
    <div class="container">
        <div class="header">
            <h1>ü´ß Bubble Shooter</h1>
        </div>
        
        <div class="game-controls">
            <div class="control-item">
                <span>Score:</span>
                <span id="score">0</span>
            </div>
            <div class="control-item">
                <span>Level:</span>
                <span id="level">1</span>
            </div>
            <div class="control-item">
                <span>Bubbles:</span>
                <span id="bubblesLeft">0</span>
            </div>
            <button class="btn" onclick="newGame()">New Game</button>
            <button class="btn secondary" onclick="pauseGame()">Pause</button>
        </div>
        
        <div id="message" class="message" style="display: none;"></div>
        
        <div class="game-container">
            <canvas id="gameCanvas" class="game-canvas" width="500" height="600"></canvas>
            <div class="aiming-line" id="aimingLine"></div>
            
            <div class="shooter-area">
                <div class="shooter-bubble" id="currentBubble"></div>
            </div>
            
            <div class="next-bubble" id="nextBubble"></div>
            
            <div class="bubble-colors">
                <div class="color-indicator" style="background: #FF6B6B;" title="Red bubbles"></div>
                <div class="color-indicator" style="background: #4ECDC4;" title="Cyan bubbles"></div>
                <div class="color-indicator" style="background: #45B7D1;" title="Blue bubbles"></div>
                <div class="color-indicator" style="background: #96CEB4;" title="Green bubbles"></div>
                <div class="color-indicator" style="background: #FFEAA7;" title="Yellow bubbles"></div>
                <div class="color-indicator" style="background: #DDA0DD;" title="Purple bubbles"></div>
            </div>
        </div>
    </div>
    
    <div class="win-celebration" id="winCelebration">
        <div class="win-content">
            <h2>üéâ Level Complete!</h2>
            <p>All bubbles cleared!</p>
            <p><strong>Score:</strong> <span id="finalScore"></span></p>
            <p><strong>Bonus:</strong> <span id="bonusScore"></span></p>
            <button class="btn" onclick="nextLevel()">Next Level</button>
            <button class="btn secondary" onclick="newGame(); hideWinModal();">Restart</button>
        </div>
    </div>

    <script>
        class BubbleShooterGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.bubbleRadius = 20;
                this.bubbleColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'];
                this.colorNames = ['red', 'cyan', 'blue', 'green', 'yellow', 'purple'];
                
                this.bubbles = [];
                this.shooterBubble = null;
                this.nextBubble = null;
                this.aimAngle = 0;
                this.shooting = false;
                this.projectile = null;
                
                this.score = 0;
                this.level = 1;
                this.bubblesLeft = 0;
                this.gameRunning = true;
                this.gamePaused = false;
                
                this.shooterX = this.canvas.width / 2;
                this.shooterY = this.canvas.height - 50;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.createLevel();
                this.generateBubbles();
                this.gameLoop();
                this.showMessage("Aim and shoot bubbles to match 3 or more of the same color!", "info");
                
                // Track game start for analytics
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'game_start', {
                        'game_name': 'bubble_shooter'
                    });
                }
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!this.shooting && !this.gamePaused) {
                        this.updateAim(e);
                    }
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (!this.shooting && !this.gamePaused && this.gameRunning) {
                        this.shoot();
                    }
                });
                
                // Touch events for mobile
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.shooting && !this.gamePaused) {
                        const touch = e.touches[0];
                        const rect = this.canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        this.updateAimFromCoords(x, y);
                    }
                });
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.shooting && !this.gamePaused && this.gameRunning) {
                        this.shoot();
                    }
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !this.shooting && !this.gamePaused && this.gameRunning) {
                        e.preventDefault();
                        this.shoot();
                    }
                });
            }
            
            updateAim(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.updateAimFromCoords(x, y);
            }
            
            updateAimFromCoords(x, y) {
                const dx = x - this.shooterX;
                const dy = y - this.shooterY;
                this.aimAngle = Math.atan2(dy, dx);
                
                // Limit aiming angle (can't shoot backwards)
                const maxAngle = Math.PI * 0.8;
                const minAngle = Math.PI * 0.2;
                this.aimAngle = Math.max(minAngle, Math.min(maxAngle, this.aimAngle));
            }
            
            createLevel() {
                this.bubbles = [];
                const rows = Math.min(6 + this.level, 12);
                const cols = 15;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        // Offset every other row for hexagonal pattern
                        const offsetX = (row % 2) * this.bubbleRadius;
                        const x = col * this.bubbleRadius * 2 + this.bubbleRadius + offsetX;
                        const y = row * this.bubbleRadius * 1.7 + this.bubbleRadius;
                        
                        if (x <= this.canvas.width - this.bubbleRadius && Math.random() < 0.8) {
                            const colorIndex = Math.floor(Math.random() * Math.min(4 + this.level, this.bubbleColors.length));
                            this.bubbles.push({
                                x: x,
                                y: y,
                                color: this.bubbleColors[colorIndex],
                                colorName: this.colorNames[colorIndex],
                                row: row,
                                col: col
                            });
                        }
                    }
                }
                
                this.bubblesLeft = this.bubbles.length;
            }
            
            generateBubbles() {
                // Generate current shooter bubble
                const colorIndex = Math.floor(Math.random() * this.bubbleColors.length);
                this.shooterBubble = {
                    color: this.bubbleColors[colorIndex],
                    colorName: this.colorNames[colorIndex]
                };
                
                // Generate next bubble
                const nextColorIndex = Math.floor(Math.random() * this.bubbleColors.length);
                this.nextBubble = {
                    color: this.bubbleColors[nextColorIndex],
                    colorName: this.colorNames[nextColorIndex]
                };
                
                this.updateBubbleDisplay();
            }
            
            updateBubbleDisplay() {
                const currentElement = document.getElementById('currentBubble');
                const nextElement = document.getElementById('nextBubble');
                
                currentElement.style.backgroundColor = this.shooterBubble.color;
                currentElement.style.color = this.getContrastColor(this.shooterBubble.color);
                currentElement.textContent = '‚óè';
                currentElement.setAttribute('aria-label', `Current bubble: ${this.shooterBubble.colorName}`);
                
                nextElement.style.backgroundColor = this.nextBubble.color;
                nextElement.style.color = this.getContrastColor(this.nextBubble.color);
                nextElement.textContent = '‚óè';
                nextElement.setAttribute('aria-label', `Next bubble: ${this.nextBubble.colorName}`);
            }
            
            getContrastColor(hexColor) {
                // Simple contrast calculation
                const r = parseInt(hexColor.substr(1, 2), 16);
                const g = parseInt(hexColor.substr(3, 2), 16);
                const b = parseInt(hexColor.substr(5, 2), 16);
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                return brightness > 128 ? '#000000' : '#FFFFFF';
            }
            
            shoot() {
                if (this.shooting || !this.shooterBubble) return;
                
                this.shooting = true;
                this.projectile = {
                    x: this.shooterX,
                    y: this.shooterY,
                    vx: Math.cos(this.aimAngle) * 8,
                    vy: Math.sin(this.aimAngle) * 8,
                    color: this.shooterBubble.color,
                    colorName: this.shooterBubble.colorName,
                    radius: this.bubbleRadius
                };
                
                // Move next bubble to current
                this.shooterBubble = this.nextBubble;
                this.generateNextBubble();
                this.updateBubbleDisplay();
            }
            
            generateNextBubble() {
                const colorIndex = Math.floor(Math.random() * this.bubbleColors.length);
                this.nextBubble = {
                    color: this.bubbleColors[colorIndex],
                    colorName: this.colorNames[colorIndex]
                };
            }
            
            gameLoop() {
                if (!this.gameRunning || this.gamePaused) {
                    requestAnimationFrame(() => this.gameLoop());
                    return;
                }
                
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                if (this.projectile) {
                    // Update projectile position
                    this.projectile.x += this.projectile.vx;
                    this.projectile.y += this.projectile.vy;
                    
                    // Wall collision
                    if (this.projectile.x <= this.projectile.radius || 
                        this.projectile.x >= this.canvas.width - this.projectile.radius) {
                        this.projectile.vx *= -1;
                    }
                    
                    // Top wall collision
                    if (this.projectile.y <= this.projectile.radius) {
                        this.attachBubble();
                    }
                    
                    // Bubble collision
                    for (let bubble of this.bubbles) {
                        const dx = this.projectile.x - bubble.x;
                        const dy = this.projectile.y - bubble.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.projectile.radius + this.bubbleRadius) {
                            this.attachBubble();
                            break;
                        }
                    }
                    
                    // Bottom boundary - game over
                    if (this.projectile.y > this.canvas.height) {
                        this.projectile = null;
                        this.shooting = false;
                    }
                }
            }
            
            attachBubble() {
                if (!this.projectile) return;
                
                // Find the best position to attach the bubble
                const attachPos = this.findAttachPosition();
                
                // Add bubble to the grid
                const newBubble = {
                    x: attachPos.x,
                    y: attachPos.y,
                    color: this.projectile.color,
                    colorName: this.projectile.colorName,
                    row: attachPos.row,
                    col: attachPos.col
                };
                
                this.bubbles.push(newBubble);
                this.bubblesLeft++;
                
                // Check for matches
                const matches = this.findMatches(newBubble);
                if (matches.length >= 3) {
                    this.removeMatches(matches);
                    this.dropOrphanedBubbles();
                    this.score += matches.length * 10;
                    
                    // Announce match for screen readers
                    if (window.accessibilityEnhancer) {
                        window.accessibilityEnhancer.announce(`Matched ${matches.length} ${newBubble.colorName} bubbles!`);
                    }
                } else {
                    // Add penalty for non-matching shot
                    this.score = Math.max(0, this.score - 1);
                }
                
                this.projectile = null;
                this.shooting = false;
                
                this.checkWinCondition();
                this.updateDisplay();
            }
            
            findAttachPosition() {
                // Simplified attachment - find closest bubble and attach near it
                let closestBubble = null;
                let minDistance = Infinity;
                
                for (let bubble of this.bubbles) {
                    const dx = this.projectile.x - bubble.x;
                    const dy = this.projectile.y - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestBubble = bubble;
                    }
                }
                
                if (closestBubble) {
                    // Find empty position near the closest bubble
                    const positions = this.getAdjacentPositions(closestBubble.row, closestBubble.col);
                    
                    for (let pos of positions) {
                        if (!this.isBubbleAt(pos.row, pos.col)) {
                            return {
                                x: pos.x,
                                y: pos.y,
                                row: pos.row,
                                col: pos.col
                            };
                        }
                    }
                }
                
                // Fallback - attach at top
                return {
                    x: this.projectile.x,
                    y: this.bubbleRadius,
                    row: 0,
                    col: Math.floor(this.projectile.x / (this.bubbleRadius * 2))
                };
            }
            
            getAdjacentPositions(row, col) {
                const positions = [];
                const isEvenRow = row % 2 === 0;
                
                // Define offset patterns for hexagonal grid
                const offsets = isEvenRow ? 
                    [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]] :
                    [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]];
                
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newCol >= 0) {
                        const offsetX = (newRow % 2) * this.bubbleRadius;
                        const x = newCol * this.bubbleRadius * 2 + this.bubbleRadius + offsetX;
                        const y = newRow * this.bubbleRadius * 1.7 + this.bubbleRadius;
                        
                        if (x >= this.bubbleRadius && x <= this.canvas.width - this.bubbleRadius) {
                            positions.push({
                                row: newRow,
                                col: newCol,
                                x: x,
                                y: y
                            });
                        }
                    }
                }
                
                return positions;
            }
            
            isBubbleAt(row, col) {
                return this.bubbles.some(bubble => bubble.row === row && bubble.col === col);
            }
            
            findMatches(startBubble) {
                const matches = [];
                const visited = new Set();
                const queue = [startBubble];
                
                while (queue.length > 0) {
                    const bubble = queue.shift();
                    const key = `${bubble.row}-${bubble.col}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    matches.push(bubble);
                    
                    // Find adjacent bubbles of the same color
                    const adjacent = this.getAdjacentPositions(bubble.row, bubble.col);
                    for (let pos of adjacent) {
                        const adjacentBubble = this.bubbles.find(b => 
                            b.row === pos.row && b.col === pos.col && b.color === startBubble.color
                        );
                        
                        if (adjacentBubble && !visited.has(`${adjacentBubble.row}-${adjacentBubble.col}`)) {
                            queue.push(adjacentBubble);
                        }
                    }
                }
                
                return matches;
            }
            
            removeMatches(matches) {
                for (let match of matches) {
                    const index = this.bubbles.indexOf(match);
                    if (index > -1) {
                        this.bubbles.splice(index, 1);
                        this.bubblesLeft--;
                    }
                }
                
                this.showMessage(`Great! Cleared ${matches.length} bubbles!`, "success");
            }
            
            dropOrphanedBubbles() {
                // Find bubbles connected to the top
                const connected = new Set();
                const queue = [];
                
                // Start with top row bubbles
                for (let bubble of this.bubbles) {
                    if (bubble.row === 0) {
                        queue.push(bubble);
                        connected.add(`${bubble.row}-${bubble.col}`);
                    }
                }
                
                // Flood fill to find all connected bubbles
                while (queue.length > 0) {
                    const bubble = queue.shift();
                    const adjacent = this.getAdjacentPositions(bubble.row, bubble.col);
                    
                    for (let pos of adjacent) {
                        const adjacentBubble = this.bubbles.find(b => b.row === pos.row && b.col === pos.col);
                        if (adjacentBubble && !connected.has(`${adjacentBubble.row}-${adjacentBubble.col}`)) {
                            connected.add(`${adjacentBubble.row}-${adjacentBubble.col}`);
                            queue.push(adjacentBubble);
                        }
                    }
                }
                
                // Remove orphaned bubbles
                const orphaned = this.bubbles.filter(bubble => 
                    !connected.has(`${bubble.row}-${bubble.col}`)
                );
                
                if (orphaned.length > 0) {
                    for (let bubble of orphaned) {
                        const index = this.bubbles.indexOf(bubble);
                        if (index > -1) {
                            this.bubbles.splice(index, 1);
                            this.bubblesLeft--;
                        }
                    }
                    
                    this.score += orphaned.length * 20; // Bonus for dropping bubbles
                    this.showMessage(`Bonus! Dropped ${orphaned.length} orphaned bubbles!`, "success");
                }
            }
            
            checkWinCondition() {
                if (this.bubbles.length === 0) {
                    this.showWinModal();
                } else if (this.bubbles.some(bubble => bubble.y > this.canvas.height - 100)) {
                    this.showMessage("Game Over! Bubbles reached the bottom!", "warning");
                    setTimeout(() => this.newGame(), 2000);
                }
            }
            
            showWinModal() {
                const bonusScore = this.level * 500;
                this.score += bonusScore;
                
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('bonusScore').textContent = bonusScore;
                document.getElementById('winCelebration').style.display = 'flex';
                
                this.gameRunning = false;
                
                // Track win for analytics
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'level_end', {
                        'level_name': `bubble_shooter_level_${this.level}`,
                        'success': true,
                        'score': this.score
                    });
                }
                
                // Announce win for screen readers
                if (window.accessibilityEnhancer) {
                    window.accessibilityEnhancer.announce(`Level ${this.level} completed! Score: ${this.score}`, true);
                }
            }
            
            nextLevel() {
                this.level++;
                this.hideWinModal();
                this.createLevel();
                this.generateBubbles();
                this.gameRunning = true;
                this.showMessage(`Level ${this.level} - More challenging bubbles ahead!`, "info");
            }
            
            newGame() {
                this.level = 1;
                this.score = 0;
                this.gameRunning = true;
                this.gamePaused = false;
                this.shooting = false;
                this.projectile = null;
                
                this.createLevel();
                this.generateBubbles();
                this.updateDisplay();
                this.showMessage("New game started! Clear all bubbles to advance!", "info");
            }
            
            pauseGame() {
                this.gamePaused = !this.gamePaused;
                const pauseBtn = document.querySelector('button[onclick="pauseGame()"]');
                pauseBtn.textContent = this.gamePaused ? 'Resume' : 'Pause';
                
                if (this.gamePaused) {
                    this.showMessage("Game paused. Click Resume to continue.", "info");
                } else {
                    this.showMessage("Game resumed!", "info");
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw aiming line
                if (!this.shooting && !this.gamePaused) {
                    this.drawAimingLine();
                }
                
                // Draw bubbles
                for (let bubble of this.bubbles) {
                    this.drawBubble(bubble.x, bubble.y, bubble.color);
                }
                
                // Draw projectile
                if (this.projectile) {
                    this.drawBubble(this.projectile.x, this.projectile.y, this.projectile.color);
                }
                
                // Draw pause overlay
                if (this.gamePaused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '36px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                }
            }
            
            drawBubble(x, y, color) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, this.bubbleRadius, 0, Math.PI * 2);
                this.ctx.fillStyle = color;
                this.ctx.fill();
                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Add highlight
                this.ctx.beginPath();
                this.ctx.arc(x - 7, y - 7, 8, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.fill();
            }
            
            drawAimingLine() {
                const lineLength = 150;
                const endX = this.shooterX + Math.cos(this.aimAngle) * lineLength;
                const endY = this.shooterY + Math.sin(this.aimAngle) * lineLength;
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.shooterX, this.shooterY);
                this.ctx.lineTo(endX, endY);
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([10, 5]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            updateDisplay() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('bubblesLeft').textContent = this.bubblesLeft;
            }
            
            showMessage(text, type) {
                const messageEl = document.getElementById('message');
                messageEl.textContent = text;
                messageEl.className = `message ${type}`;
                messageEl.style.display = 'block';
                
                setTimeout(() => {
                    messageEl.style.display = 'none';
                }, 3000);
                
                // Announce message for screen readers
                if (window.accessibilityEnhancer) {
                    window.accessibilityEnhancer.announce(text);
                }
            }
            
            hideWinModal() {
                document.getElementById('winCelebration').style.display = 'none';
            }
        }
        
        let game;
        
        function newGame() {
            if (game) {
                game.newGame();
            } else {
                game = new BubbleShooterGame();
            }
        }
        
        function pauseGame() {
            if (game) {
                game.pauseGame();
            }
        }
        
        function nextLevel() {
            if (game) {
                game.nextLevel();
            }
        }
        
        function hideWinModal() {
            document.getElementById('winCelebration').style.display = 'none';
        }
        
        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            game = new BubbleShooterGame();
        });
    </script>
</body>
</html>