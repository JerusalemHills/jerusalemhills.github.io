"
Intro
we have launched thank you so much this is a huge honor to be here thank you I
gonna be talking about a couple of different algorithms but before getting to algorithms I kind of wanted to start
with well why you should care about me and what we're doing to begin to I think give a little bit of background so I'm Marc natal I'm I like to climb things
that are very very tall up but that's kind of irrelevant to the actual algorithm discussion so what I'd like to
kind of start off with is actually talking about ok there's this pipe dream of these different applications these
doubts that people want to build but it's often for tomorrow so rather than actually saying oh here's a bunch of
stuff you could use gun and then you could potentially go out there and build this nope let's actually start with some gaps that exist today by showing not
telling so first of all is peer-to-peer reddit I'm gonna bounce out after he
just got me set up in the hopefully it's so screen recording which I believe it
is and everybody even on your phone hit up this URL not a bug dot IO it's gonna
load this website that looks an awful lot like Reddit ok but it does not read it it's decentralized reddit so I cannot
vouch for anything that is here content that reddit's mad enough decentralized right it might be worse so I'm gonna pop
up over whoops how do i screen adjust
over here as well but I want to show you this is running off of gun I'm gonna scroll down to infinity load so as I
scroll through the page you notice that a bunch of these other upvoted content I
just keep on scrolling and keep on scrolling and gun is able to synchronize that data and it's potentially
synchronizing it from other browser peers from other people who are on this website right now so I'm gonna scroll up
and find a victim of choice I don't know what this is actually let's do one that
has some comments on it already scroll Scroll scroll all I'll use this
one three comments hopefully it's not that I'm gonna jump over to this here and I'm gonna click on
the one that also has three comments scroll down and I'm gonna do testing one two three it's gonna do a little bit of
proof of work that's not based off of gun that's just what the decent you saw that my comment instantly showed
up on the other screen woohoo so that's what gun is doing it's coordinating decentralized data sync underneath you
might be going oh well this is running off of some server that's skeptical you know it might be running a bunch of
centralized or federated logic behind we're gonna actually click on that known peer link at the bottom I don't know how
many of these are currently up these are a bunch of other hosts that are also providing the data but again even if
you're loading it through one of these hosts when you are on the website in the browser it's also providing and
synchronizing data so this host looks like it's a little bit small slower but if I give it a minute a lot slower than
the main one we should see that pulls in the content from a completely different
peer in this case it's a super period but you're also pulling the data from the browser itself so that should be
pretty exciting that that decentralized reddit exists today so now go post
something creepy or weird or I don't know it's hopefully hopefully the community went to being a good community
versus reddit like Oh a jumping back to
DTube
this so on the first day that they launched just a couple weeks ago they did a half terabyte of traffic on day
one so we're talking about not only does decent choice but it exists that not only do these DAPs exist today but
they're also doing a lot of traffic on them there's another one that I was going to do D tube it's a peer-to-peer
YouTube built off of steam ipfs for videos and they're gonna be releasing a gun into IND encrypted message chat kind
of like signal or telegram and I had a demo all prepared for you about it suck on that laptop and that laptop is anyone
to do the screen recording and I also made the mistake of doing a git pull from the D Tube github account and they
had a bunch of breaking code and I wasn't fast enough to rewind stuff so you'll just have to go to that
separately I I am there is another demo I want to show you but maybe I'll come
back that oh yes no I do have it on like this computer sorry I switched computers right before as soon as we arrived it's
Social Network
gonna jump back this is a peer-to-peer social network that I'm working on just kind of my spare time so nothing nothing too fancy
but mostly for fun project built on top of gun so he's got this really cool
ability where I can use a regular ol username and password to log in now I'm
gonna explain what's actually happening later because it is actually cryptographically secure and there is no server that's operating off of us so I'm
gonna sign up of course if I switch computers I'm sure it's about yes let me
for whatever reason this laptop doesn't like file having access to local storage
which is very important for doing peer-to-peer stuff in the browser so I'm gonna go to something that have just
with a local gun instance running all right so martinet ow I'm going to create a password login we'll cover what what
that does later and I'm gonna jump to the news feed I actually need do you
have like a random photo I can drop in that's my profile picture good I'll use
thank you will you see you as there we go perfect then come over to back to
settings awesome well welcome Gabriel I'm gonna drop this
in it'll pop up there so I'm now impersonating Gabriel I'm gonna say hello world yay we have my little icon
I'm gonna open up this over here take my
local instance pop over here I'm gonna create a new account I should do Gabriel
but again I'll explain the cryptography
a little bit later just want to show you what it's doing although of course now
that I've scrambled it going on our machine it looks like I'm having a bit of a demo failure so part of me I'm
gonna have to ditch and come back in a minute so this was working on my
machine I don't quite know what the problem is over here ah would that be too bad okay
sweet so left and I have window snapping
on this machine all right so I'm gonna create that user I'm gonna make sure
actually I need to turn this back on
okay now we should be in business let me log out just for safety precautions
give me one extra second and reset everything local storage clear kill time
all right and then close that and I
should be on a clean slate now okay
because they're just uh random faces I
fast but hopefully in the future okay
there we go hopefully a disaster averted user
already created sign-in okay seems slightly fishy but I'll roll with it and
I'll apologize if it backfires on me again okay I'm gonna drag and drop in an
image so where's my cursor drop
Amber's photo into here and I should have a photo here I'm gonna drop in go
over to here go over to the newsfeed it doesn't look like Facebook what it is
hello world and there you go it pops up instantly happiness and typos the cool
thing is unlike in a mutable append-only
blockchain or ledger or database a lot of things out there I'm gonna come back
to settings and I'm going to change my photo okay a very important feature that
for a lot of gaps we need oh that actually here let me drop it in again so that way you see that happening when I
drop in this photo I'll drop it in my previous Status Messages update so this
is all in tange cryptographically secure we're gonna go into the math and the coding and the logic behind it in just a minute and as well as the high / low
architecture but hopefully it just gets you excited that actually we're able to create these these dreamed of daps that
might replace Facebook might replace Reddit and you can already do them today
now we can switch back to that machine alright so jumping into Firefox which
has the presentation so now that you have a little bit background of what can be done day why am i building this so fluffy
Background
kind of intro story back in 2010 I was working in a collaborative web design tool it was really awesome that's mind
blowing was amazing and it forced me to learn whole kind of distributed system stuff I was doing you know basically
operational transformation level stuff but fully peer-to-peer back in 2010 using cedar duties before I found out
that CEO duties but even coined but we got a little bit of traffic from The Wall Street Journal that covered us and
our entire website follow it fell over in the middle of night so I get the pager called a cliche a pager call at
3:00 a.m. I wake up all groggy and I ssh into the server to figure out what's wrong and everything is fine except for
the stinking master slave database if the database is down then doesn't matter
it's the heart of the whole rest of the system if the database is down doesn't matter if your application server is fine if the front end is fine all this
stuff if it's fine if it's not getting the blood pumped to it by the database then you're screwed so I realized hey I
actually have some experience with doing these distributed concurrency control stuff I might as well run start building my own database
cuz I was naive and I thought it can't be too hard so I took all the best features out there that I liked
everything from real time pictures with firebase and everything DB to craft features of neo4j and rain go to offline
first features of couch and I can't really call Cassandra and react they centralized they're certainly mastered
mastery which is more towards decentralized and peer-to-peer but the fact that you still need a really large server to run them on kind of makes it
favorable towards server oriented architecture versus just running on your local device so from an algorithm side
like I pulled all these pieces together and developers love dead right so we've grown to about the same size of a
community that ipfs was a year ago so a ton of people have jumped in their building the other cool stuff I showed
you earlier on top but now where are we going well there turns out to be this one
The Problem
sucky really annoying terrible frustrating thing
I want my peer-to-peer apps to see still kind of sucks and this is a problem
across the board whether its web torrent I know for us and you know he's done some of the best work with WebRTC on
whether it's the DAT team the ipfs team a bunch of these different aims out there what / TC is still kicking us in the butt like it's just super annoying
and as a result if people like D Tube Adrian who runs D tube he's gonna be out here and at the month and the guy who's
running decentralized reddit I don't actually quite know his name his he goes by goldfish online so he's truly
anonymous these people actually have real apps that are already deployed with a bunch of users hitting their site and
when ipfs and done and these other systems can't make these web RTC
connections that ultimately means that all of that data and bandwidth and traffic has to get funneled through a
server which is annoying this isn't really our fault it's the limitation of the browser but it then creates some
issues you might have a tendency to go the route that Facebook did if you're providing a bunch of photos and tweets
and connectivity for your users you're gonna then start mining their data and selling it to advertisers
because if you're running this peer-to-peer app you're trying to do it to save money partly and also
decentralize the world by using the decent fly stack and now you're paying for all of your free users so the way we
kind of get around that is we're introducing this new thing called ax which you can think of as being a
decentralized int and encrypted karoku so it you know we're not trying to push
a theorem aside we're not trying to push ipfs or file point aside specifically surround this idea of how to do data
sync if we just have a bunch of random servers out there that are all running the same system on it then we can
transmit data through we can route data through a whole ton of different servers now that one's up producing another
problem which is aside from the economic incentive why would you do that if you
know that you're not getting paid for it the second problem is the only reason that I trust when I pick up my phone and
dial my mom and don't worry I'll get to code and some math pretty soon just to
kind of frame the problem first the only reason why trust that when I doubt my mom's phone number that my mom's actually gonna pick up is because
I trust that some middleman of AT&T t-mobile etc is gonna route the call for me well the reason why I sent a Facebook
message to one of you that I trust it's actually going to arrive at your side is because I trust that Facebook as a
middleman is gonna deliver it correctly if we remove those middlemen and we have a fully peer-to-peer network and I wind
up trying to send some data there's no guarantee that the data is actually going to be received so we had to come up with well how do we make sure that
there's a cryptographic guarantee and a decentralized network of the data is actually being synced to the other pair
thus proof of propagation correct yes so
the cryptocurrency is acts has more to do with economic incentive because if
I'm providing a server that emulates peer-to-peer traffic but I'm not able to mine that data cuz it's all int and
encrypted then I'm basically just shooting myself in the foot with a large server bill now ideally further on the
future whenever to see in stuff that's working then we don't have to worry about that but for now the people who are running the servers in the first
place need a very strong incentive to actually run the servers and mine backs
tokens the the bandwidth off of it so does that make sense it's more of a temporary economic fix than necessarily
the end goal and that is because largely the tech for doing peer-to-peer stuff is
still a ways out
yes and I actually answer that a little bit later in the talk where axe actually
is a federated architecture on top to make the system scalable but it doesn't
violate any of the peer-to-peer primitives under Teague yes already is
correct just in terms of enterprise and blockchain notes there is no enterprise
I should actually run a blockchain because the performance if a blockchain an enterprise setting is going to be miserably disgusting compared to
permissioned peers machines the nodes and databases on their own server because with a blockchain you have all
the cryptographic overhead that you have to do in the public network because you're not strong I would love to hear
more Oh Oh with rust the rust implementation you could go faster but then any rust implementation of that
system in the enterprise world without the cryptographic overheads but still outperform that system so just be an
inevitable arms race of technology so we're actually pretty skeptical against
a lot of cryptocurrencies blockchains it's tough out there because they're just miss applied a quick this is the
investor pitch you didn't want me to do that you brought it up is is I only see three layers as being important for
having a cryptocurrency behind and that is the physical resources that machines use the physical resources that a
machine use is storage thus file points at you know and ipfs is huge explosion
computation ok theorem Definity another ones out there and we're missing a really important component which is
bandwidth of marty and i marty was the very first contributor to bitcoin after
Satoshi Satoshi even handed over the URL the domain and the Bitcoin clients
already got Bitcoin on to get and a
bunch of other things he also update the website very influential in 2010 and he
wound up believing before even like Gavin and others came on board Marty has joined our team and he's kind of got the
similar kind of skepticism as I do about a lot of these blockchain cryptocurrencies but an important
problem is that even with Bitcoin his beloved child right a lot of the mining peers
have our IP addresses part of code into the client that is a perfect blacklist
for China to just take those IP addresses and blacklist it on their network so that presents actually a
pretty threatening dangerous problem to the peer-to-peer world the decentralized man with the crypto movement because if
we aren't able if we still have this old model of IP addresses or domains that
people are able to kind of whitelist and blacklist we can easily get oppressed and pushed underground and a second
layer is net neutrality is pretty popular right now and my philosophies why not just do nothing shoddy of a cryptographic layer right that all right
okay does that make sense so there's three things that we view as being important and bandwidth has kind of been a missing equation and we don't solve
that it's actually going to stall progress we're not gonna move forward so
How It Works
how it works again we'll get to math in just a second high level thing actually
turns out it's pretty easy to do cryptographic verification the data is transmitted and you would do this regardless of whether you have cryptocurrency running or not so the
laptop winds up being like hey hey hey I want to get a bunch of server peers that
not might be relaying the data so it makes step one request up to you know it
could be a physical router but realistically right now it's gonna be a traditional server and then in the future it's able to run on a router and
these relay peers these propagating peers send back and step to a smart
contract of the rates of the bandwidth that they're gonna be provided how much the laptop is gonna have to pay for band
was to go through those super dressed now this laptop in step three is able to choose one or many servers based off of
the best rates and sins a test message probably like 10 bytes or something like that up to the relay here the relay peer
is then going to propagate it out and there's two important pieces right here the relay peer doesn't trust the laptops
but might want to check to see if the coins that the hot top is offering as a payment for the bandwidth isn't actually
double spent the laptop itself doesn't have a guarantee yet that server is
gonna relay and it turns out that it's actually faster for the server because 10 bytes at
today's bandwidth rates is a millionth of a penny it's actually faster for the
server to perform the double spending check while the network is performing the check because and so I'll get back
to them just a second then the phone who's the intended recipient receives
this and cryptographically signs off that they've received the 10 bytes and acknowledges it that acknowledgment gets
sent back to the laptop so now the laptop quite simply I mean there's nothing super complicated to proof of
propagation this is a cryptographic signature that goes back to the laptop that yes they did indeed communicate and
with that phone and that proof the pop
is important for the laptop to make sure that you know they know the server's not screwing them over but it's also
important for the server because now if the the server has a cryptographic receipt that they actually delivered on
the goods if it winds up happening that the laptop attempts to school or the server run away the laptop can hold on
to that cryptographic receipt and be like no I did indeed send this data and we'll get to that in a minute I want to
explain some other components of the math and a little bit of like not code first but I'll get to code afterwards and then once that initial session has
been established you kind of resume the flow we're in seven we basically update
our bid to the server and we ask for more bandwidth and then we go back to
step number four and it flows through the system there's that better slide in just a second but I want to go over the
math first so there's lots of missing pieces but you need to observe something
which is if we're talking about trying to have cryptographically verified peer-to-peer bandwidth global traffic is
about a hundred terabytes of data per second to compare this to Bitcoin right which is less than 200 gigabytes over a
decade so the the scale that this thing has to operate if we want to hit our end
goal is is orders of magnitude orders of magnitude larger than any blockchain can
even possibly imagine any it's just so far beyond to mostest
implementation so I'm gonna be here to say hey sorry guys Pal D pause pause all
these different blockchain implementations they're great for certain use cases but they are not going to let us achieve the future that we
Math
want so math not too bad here a little bit fun right we have a private key we
have a public key which is derived from the private key we have encryption for asymmetric and decryption quite simply a signature
winds up being the decryption of the checksum of the data by the private key that actually when I first thought in
math kind of blew my mind because I'm used to taking a public key encrypting data sending it to the private key that
decrypt says that way you can only wind up having the private key decrypt it but actually the way that the the signature
itself happens is the private key encrypts data that then any public key
is able to decrypt I was like wow that actually makes this from an asymmetric mathematical respect to everyone I put it into math so I thought that was just
it made me realize wow this this actually makes sense underneath from my cryptography standpoint and then the
same thing if you if the use of public key to decrypt the signature and you get the check sum up the data I tried to
make this work with Bitcoin initially because I have huge skepticism descriptive kerosene block chains it's like well why not just use Bitcoin right
like this obvious solution however write it if we're doing hundred terabytes of
data throughput per second it's just not gonna work you so actually what we're
proposing here is somewhat like that payment channel so you DT I'm kind of lightening channel you know state
channels and lightning networks I feel like steal a lot of work from CDT world and cross apply them back to the
block there's some trade-off yeah it's gonna be somewhat related in how it works
except for better but so the beautiful thing with this is is once we have this
signature representation of the contract that's been sent for so the bid is the data of that the tokens for data
imagines Bitcoin so it's easier you know the checksum of the bid which gives you the hash and it's signed with it's encrypted the
private key to give you the signature we're then able to use this to form a miracle tree which has some really
wonderful properties if you guys aren't already aware of Merkel trees but also some hidden hints by Satoshi whitepaper
the original Bitcoin white paper is that we're then able to take all these bids because I told you that the laptop and
the server are going through a constant exchange of changing the contract and
that means we need fundamentally underneath gun to act as a data synchronization protocol to make sure
that byte for byte those contracts are the same as it being mutated with a different with a different you know how
many tokens are inside of it and as long as god is doing its job so you actually can't build the system without some sort
of gun like system we're able to then take this many different bids over time
for the session of the data transmission and form a Merkel tree where we have you
know that basically the signature of the bid and its signature all the way out to the the int number of the bid in the
session and the signature I think we then take that whole thing and we can take the the hash of that the checksum
of that and encrypt it with a private key and that gives us a super-short
nice cryptographic guarantee that both parties were involved in this
transaction and the reason why that's important is because now either party can dump that to a blockchain in a
traditional blockchain sense and any peer other peers in the world can verify that both parties were involved so if
the laptop doesn't dump this to a blockchain the the server it's fine the
server has proof of it if the server doesn't dump it to a blockchain the laptop can and have proof
of it this last few lines oh sorry this was actually very important it's why
Bitcoin and accidents go well together other than scaling issues
how does mining work in the system so I'll show this in code the signature
chain as a on these coins I can hand it off and hand it off and off is gonna grow very rapidly and signatures are aren't public keys aren't
particularly short so if I have a token that pays for 100 kilobytes of data and
the signature chain every single time I transact for that type of data I have to
put more data on that token that is then also getting sitting over the network very quickly I might have a token that
has 10 kilobytes of data it only pays for 100 kilobytes and then as I transact that a little bit more that signature
chains going to grow grow grow we might have a token that has you know 50 kilobytes of signature chain data on it
for only now 100 kilobytes of data transfer where that means we're losing the bang for our buck over time so what
the server can do technically any printer can do this but you just have to be the owner of the coin at that point
in time and it makes sense for the propagating peers to do this because while there I Oh is heavy they're not so
so they might as well perform the Merkel hash of that signature chain to produce
a significantly smaller new token that can then later be circulated and through other mechanisms validated and acts as a
as a new token and and that new token is significantly shorter so the system is
able to keep up with scaling you don't have this cryptographic all this cryptographic waste that's just
generated with you know hundreds of gigabytes and hundreds of gigabytes of stuff that's just left over does that
make sense yeah that's true if if you are Merkel
hashing on a double spent coin doesn't matter how much work you dude you're getting screwed over so how this
technically doesn't actually solve a double spending problem Bitcoin is famous from an academic site for actually solving the double spending
problem because we have network connectivity it's actually useful that we're able to solve at least 97 percent
or more of double spending situations because the network is live in database where others think called a cap theorem
trade-off between strong consistency high availability partition tolerance because pop is only checking for whether
the data has been transmitted while two peers are online you're not online you just you have to do a store and forward or some other technique like using you
know file coins attenborough store the data and later when it appears come back online I did skip that point being is if you're both online
you're not gonna have partition and dollar and like you are online and so you're able to pretty quickly in most
case because the gun is able to synchronize this data so quickly sincerity T's if you'll get in in a minute verify and prevent double spins before
they even happen now that is not an academic solution okay so we still actually all address the academic
Academic Solution
solution just a second we want to give homage to Satoshi I've not seen very many people actually
use this right it's a tiny paper I don't know if you guys are aware of this but
he literally suggests this once the latest transactions are the corner berry enough blocks the spin transactions can
be discarded to save space to facilitate this without breaking the blocks hash transactions are hashed with a Merkel
tree with only the route included in the blocks hash old blocks can then be compacted by stopping off that ramp to the tree interior hashes do not need to
be stored we don't actually need to store the majority of bitcoins history but yet people are I mean those great
for auditing purposes and it is very important that we have auditing purposes but Bitcoin itself could actually be a
lot more lightweight by just throwing out basically everything after 10 20
whatever your threshold blocks have committed I hate to bring this up on on
a recording but there was recently the German researchers I believe that found
child abuse on the blockchain area but I was like oh ball chain is an immutable ledger and I was like well actually it's
the heads the Merkel hash that's in immutable ledger you can delete all that child abuse of data from Bitcoin and
still have a perfectly valid system and so I'm not quite sure I don't think many
people are actually using this feature and it solves a lot of things turns out it's great for when you're
applying it to high throughput low latency systems like bandwidth on one component that doesn't solve the whole
scaling pong it's also important to know and this is going to shock a ton of people probably frustrate them but I
know better from the actual experience of working this is the last four years and taking a completely different route
than a lot of other people in the decentralized a South is this is happening on a per coin basis and the reason why is if you doing
100 terabytes of data in one second okay you're not gonna have time in one second
to sync the entire blockchain on that okay even with the latest block chains that might have half second resolution
time but if you wind up having effectively the signature chain using
gun you're able to make a request for just that one signature chain and sync its entire history just for that one
coin and see the whole a signature chain to check it's up to date now
again that doesn't necessarily but since you're online and you're syncing the
information relative this one coin it actually gives you really fast heads-up advantage very quickly that you're gonna
effectively get let's say the get head of a you know like take a code
repository if you're able to very quickly get the get head on to something maybe it's slightly out of date but that
gives you such a heads-up advantage to be able to detect double spending in advance with a high throughput network
but if you wind up having to sync all of the blocks and do consensus and all this extra work it's just impossible to scale
up just a and I'm not saying that from a programming standpoint no matter how much better the blockchain consensus
algorithms get and the lower resolution they get your fighting physics here you cannot have the same piece of
information everywhere in the world simultaneously with global consensus while also having peers that are
rotating on and off so this was the side I was mentioning earlier and then I'm gonna answer a lot of these questions
Paying for bandwidth
have thrown out during this process is just as a quick reminder it's pretty simple the laptop pays for bandwidth to
get sent through some system and the goal is when we actually have WebRTC
working really well that that ideally you could actually run ax on physical Wi-Fi routers that that just doesn't
work right now because of chicken-and-egg problem so there's immediate utility that exists today this
guy receives it and he signs off on the first 10 kilobytes you're not your again the cleverness here is you're not doing
these transactions on every 10 bytes for every photo that you're sending once this session has been established that's
completely trust lists there is a high guarantee during this shouldn't of data transmission that the
laptop is able to up the ante we're in the same way with Fiat we have a penny a
dime a quarter a dollar they're in our system maybe different resolutions of
coin one that pays for you know ten bytes and it might be a single coin that
pays for ten megabytes you're realistically never going to be paying
in advance more than about two seconds or less because again the speed at which the network can actually transmit around
the world while you're online is especially if you're running through you
know a propagating appear winds up being I would have to be streaming out of my
laptop like 10 4k videos in order for my buffer of how much outgoing data I'm
sending to be at a layer that I'm paying you know 30 seconds in advance so this
isn't like your Comcast bill or something are you paying you know once a month for the entire months worth of
bandwidth you're you're able to do this at very low and high resolution levels
at very short time frequencies because
the only thing for this transaction that needs to happen is that this laptop before it makes the next transaction
which happens very fast as the smart contract syncs just between these two peers directly using done has to perform
that transaction which isn't too hard before the data is even sent so that's like al sub-millisecond and then the
second layer is before the laptop pays again the next time for the next two seconds or next one second or the next
hundred kilobytes of data it needs to have received a pop back from the Integris recipient so if you're
understanding kind of a structure there's all these amazing cheats that you can do using these data sync
algorithms they see dirty algorithms and using kind of intelligent intuition about the economics the system the
limitations constraint and system from ground up that you can build and make these highly scalable performance
decentralized peer systems that are already doing like terabytes of traffic now well what about
the act actually solving the double spending problem there's just a lot of cargo cult around block chains and block
chains this solution for everything when actually block chains very very specific use case which is solving a double spinning ball and that's then where I
Double spending
have to get all humble and honest with you guys like okay Mon you come back and be like okay we got to make sure that
the three percent edge case of people who want to double spending on the network because my wife was on the other
side of the world and I spent the same coins as her and so we they're on different relay servers if they got screwed over well it's actually not too
bad even take something like Bitcoin with ten minute blocks we need three
ingredients and is completely automatic that Merkel the the Merkel contract that
both peers have that have a cryptographic proof that they were given that coin and there's two peers that
have a coin that was double spent at the same time that that technically was a cryptographic roof that they actually were supposed to get the coin but that
you try and spend it and somehow it's not they submit this cryptographic proof the the hash of it look technically the
full Merkel contract to a traditional blockchain we could build our own but
honestly like me Marty we love Bitcoin and it's good enough so it would probably still be Powell base there's
plenty of other things we could do but just keep it simple straightforward fifty-one percent is it sounds scary but
you have to have all three components with two cryptographic receipts at the same double spent coin plus 51% compute
power that agrees upon that we can forcibly remove from the fraudster the one missing coin so even though that one
missing coin mate might only be one millionth of a penny and cost that a lot of servers might just like ignore they
are academically able within ten minutes well I should say twenty minutes
able to have one of these coins go to this guy or this guy plus maybe even
interest inside of those ten minutes does that make sense whatever the block time is on it's like
listening like I think Definity is claiming three seconds
it doesn't really matter we could build our own just using 10 minutes says we
what we're doing is we're cheating most of the time you don't actually need to
be double spend compliant you only need to be double spend compliant when criminal activities happen or you know
when when ineptitude has happened so why not use a court system after the fact
that might be you know 10 minutes it might be an hour whatever time resolution whatever existing blocks that
you want to use I still prefer Powell in this case not delegated proof of stake because you can then use that to resolve
all the the missed double spend situations that what do you need acts
because if you were to try and use this every 10 minutes there's going to be no
I agree as far as saying payment channels might be very similar to this
our patients live regular channels
since we are talking about proof of propagation to another knowing system
you know I can run a channel where you just yes if can you get screwed over cuz
I haven't studied payment channels too in-depth can you get speed over a
question um remember if we're talking about a hundred percent of the traffic of bandwidth money whose system is still
a hundred terabytes of data per second is there current theoretical math let
alone implementation details on side channels being state channels being able to do that because what we're trying to
do is offload as much possible work still being fully peer-to-peer such that then potentially only you know less than
one percent might need to run on a state channel or well it's three-way right we
want the laptop wants proof of the day was propagated the server wants proof that the that they delivered on the
goods and both parties want to make sure that if a dispute happens that there is an exact same cryptographically science
system so do again I haven't studied payment channels too much because it's the last four years but won't that
produce compounding problems because if we're talking about every ten minutes now you not only have the hundred
terabytes of traffic that have happened that the side channels have them to do every single second but you across 100
percent of the network versus just one percent of the network and then a compounding that over the next ten minutes or twenty minutes or whatever
that the block time is which is going to exponentially grow for each one of these signature chains that as it's being
transacted you're going to potentially get in you know it could be megabytes if not gigabytes of signature chains before
you even get to the next Ellucian so you're not like like it's great that we can settle up but if that's settling up requires that what to
reverse the entire history of last 10 minutes 100 terabytes per second is that's still not going to be scalable
does that make sense well no I I miss my
job as a communicator to make sure that I'm making you guys understand in this model the only thing we have to settle
is the double spent things not all transactions and as a result that then makes it
I'd say many times exponentially more performant because now we're dealing with only the edge case versus the
default case and the default case is hundred terabytes a second the huge
savings and for peer-to-peer systems especially with underlying protocols and tack and barber TC not at this layer
maybe in the future this would be possible but this is you know a solution that we can build today and and have
working and we know from a theoretical standpoint and also a mathematical standpoint skips a lot of the waste
while still being peer-to-peer it's not good I see skepticism stone your is fine
oh wait whoops so let's see if I should
Code demo
be fine on this computer let's get into a little bit of code this is just a
sample of what might happen so if you guys are bored by this you know certainly tell me - hey I cannot read
local host property I might need to switch over to I can probably use this
one
yes reference implementation is in JavaScript's because I believe in universal access and ubiquity and then
we can and here's the thing if we can get the performance working in JavaScript a joke of a programming
language it's certainly gonna be a lot more performant and rust C C++ but because javascript is lingua franca it
winds up being just it makes our bar harder to achieve so we prove ourselves
even more and on top of that it creates a nice reference implementation about
people all right so we're gonna create using guns see system security encryption authorization three public
private key pairs both PC D H and E C the SA which is what we're using so I can type in Alice and you see there's
the data here we're then going to create the Genesis block hahahahaha right so we
have a bunch of named coins and this may be very different than anything else you've seen this is just a lightweight prototype it's not it's not the actual
implementation detail it's just easier to explain so we have gin a starting at this public key it's not actually sign
of us because the Genesis block is well published everybody's agreed to it it's embedded into the the code blah blah
blah blah blah but when we want to actually perform the first transaction well we wind it yes yes there we go
oh wait so what we're going to do is since Alice owns the a key she's going
to sign it over to Bob's public key and we do that by calling seed C dot sign and we're going to push that into the
signature chain of C we didn't want to verify that the owner at the first array
index is the has been signed off by the previous owner so hit enter you'll see
that Jin a is now two items the first item is just the public key the second item you know like what is that what is
that well I wind up just saying C dot verify like I did it above Jin dot a one
right which is the one with the data and then Jin dot a zero so it
think of it as a linked list you're checking that the second item in the list has been signed off by the private
key in the first one so when I run that I do indeed get Bob's public key back so
we have a cryptographic signature that Alice has handed the coin over to Bob now we have Bob and Bob wants to
transmit some data so let's jump down to so owner is the proof of that we're
gonna jump to right oops
so now Bob wants to relay data through Karl so okay so that that line there is
Alice handing it over to Bob so we now have the new owner Jen a which is that particular coin we're gonna push that
Bob is signing the coin over to Carl dot to Carl's public key and then we want to
verify again same thing as we did before that the owner at jinda a - whoops - if
you wind up doing sita verify jen dot a to is indeed relative to the owner and
owner is Bob's public key right so pretty simple it's pretty straightforward
signature Shane yeah
um like public key distribution I would
not recommend using a server for distributing public keys I'm glad you asked this so that's one of the reasons why Marty has joined our team who is the
very first contributor to bitcoin after Satoshi has had the most interaction of Satoshi of all people on the planet
Marty has already solved this and in fact he solved it three years ago but nobody noticed or cared so he has a
system that allows us to do public it's kind of like PGP on steroids or key base but fully decentralized in the Foley
peer-to-peer so I'd love to answer that in more detail but we had him already out to talk about a few months ago we
can pull him up again it is can I kind of postpone that for maybe a talk that Marty could do okay so yeah public key
distribution is the weakest link in all cryptographic systems so be careful about that thank you for pointing out as a public
announcement oh wait let me jump back to
the yes correct so I I do have a
solution however my colleagues at MIT said that there's so much existing history that quoted me like ten
different papers on decentralized incentivized routing that I have decided
to kind of be fuzzy about that subject because one of the existing papers might
have a better implementation that well we've come up with so the quick summary this isn't going to satisfy you is that
the the mining the axe mining servers are technically operating under a federated structure but allowing
peer-to-peer underneath so it doesn't violate the peer-to-peer network these federated super peers as like to call an
island servers these propagating peers have a radix DHT where they where they
shard the public keys of connected users across their DHT and because a radix
tree has effectively oh one lookup speed relative to total data set size in oh in terms of depth size and erratic
straight but that's now it's nothing there to the total data set size we're able to do a very efficient you know
neighbor DHT algorithm that then gets to Bob's computer connected to a certain
peer and then once Bob receives that he's able to temporarily connect to the server that Alice was Radek sorted to or
a common middleman server if that server can't handle it is that satisfying for a quick answer are you familiar with like
a radix data structures and doing that with from a DHT site okay yeah all right
so a DHT actually is probably pretty terrible performance compared to a radix DHT so woohoo
all right so the last thing now is the mining house it's 8:30 already I'm I'm
ton of other material so I'll be skipping this or okay cool so now we're
gonna get down to this point where okay if Karl if Karl has the if if Bob is
signed the coin over to Carl well let me let me get rid of that
okay so jinda a is now 560 bytes we're
almost you know approaching half kilobytes so that just in three transactions the bite-size bandwidth
site is just exploding as you expecting cryptographic systems we don't have trusted middleman yeah because I much
rather have the waste then and the middleman what Carl was able to do
because now he owns the coin he's going to perform C dot work which is a pbkdf2 underneath could be you know a shot 50
SEC to whatever you want I use pbkdf2 for the work function on the login system which I may not have time to
cover and Carl then adds this new mind
coin to a block it doesn't necessarily
come to their peers and now you'll see that the the this block has a through H in this
new coin here and the value on that is Carl's public key every other peer is
able to verify that this is true because they can take because they might not
know if this is a fraudulent coin or not a counterfeit coin they can also take
the the genisis a coin up to it sorry that just the a token up to that point
that Bob did the vertical hash on it and
put in the public key that is claiming to correspond to that and they will produce the exact same mind thing as
before like pretty straightforward cryptographic verification like like this is just simple obvious stuff that
you can even do in the browser even though nobody else or very few people are actually people doing the browser we've already built it all out for you
guys so the difference here is pretty I mean only on three signatures it's still
pretty large that the new coin is 64 bytes the previous owner Shane was 509
so you can see you probably don't want to mine the coin every three signature chains but this is how you achieve
scalability in a high throughput low latency system it does take time for a
coin to be circulated so there's a constant trade-off between performance and work and stuff like that but that's
it'll be a more detailed conversation
Multiple Peers
yeah so when I mentioned that you might contact multiple peers and choose
multiple peers you're paying separate coins for both of them so you're there there is no one coin for one route
you're as soon as you're sending any data over WebRTC WebSockets UDP TCP
whatever it is UDP to to a server that servers expecting to have a token token
and then increase it does that make sense
right so what is C what is this thing now showing you what it that's running the browser it's more active all right
The Stack
so this is the stack so we have ham underneath then gun then C then rag damn
ax era all the way up to the top so we've had to build out an entire stack
of stuff you can think of it as being equivalent to this right there is a conflict resolution Algrim underneath
the co2 T which hopefully I'll actually now go to start talking about the data structure which is gun the the secure
leader authorization layer the serialization of storage layer the networking layer which is dam and then
ax which I was just explaining to you guys because actually there's a lot of questions to answer because I only
showed you kind of a tip of the iceberg and there's all this tech I would built out over the last 40 years underneath
and and by for years I mean I Frost's of web torrent one of ipfs file coin
Matthias and dat sub stack he was pretty popular at node community
all huddled together in 2014 to talk about our different approaches to
solving these decentralized problems and we've all gone our own different ways you know secure scuttlebutt dat ipfs and
gun but like this has been some pretty early work from a long time it's not this new thing that we've just showed up
in the last year and throwing things together I did move into the Bay Area in August so that's pretty recent but
elsewise it's been around for a while so ham is our specific CDT conflict-free replicated data type it's got hypothetic
our major machine I'll leave the naming as separate thing
we can talk about probably we got a C or D T's and Y's entities are going to be
better than block chains DAGs and append-only logs and hash based structures so aka
all of the decentralized competitors let's jump back into code base and hit
refresh clear out and I'm gonna show you I've never explained piracy or duty this
way before but I'm going to show it through code I actually heat switch statements so does not represent my codebase a
mathematician at Stanford that was working with said that oh if you want to formalize it give me a switch statement version and then we can convert it into
you know latex and stuff like that so I did but we have a whole cartoon explainer on how the acidity works if
you want to you know learn about how it works from like I'm five side of the equation in this specific setting we're
going to go over several different tests so there's going to be data that Alice has there's gonna be data that bob has
and we're gonna print out what that data is before it runs through the convergence function the commutative
replicated data type the C or D T and we're gonna and for the sake of demonstration I'm just mutating the data
and we should expect that Alice and Bob after it's gone through Hamm converge the exact same data and the cool thing
is you know this is run in opposite orders so Alice Bob Bob Alice and it also music can be run independently
concurrently on separate machines and get deterministic resolution so we don't
I wouldn't brag about how would is because we don't have to go through a
consensus system we get determinism for free so the first one is we have data a state one day to be state two it runs
through the system and both Alice and Bob are now at data B state two for that edge case now we're going to test every
possible edge case of the system next setup is you have data a state v data B
state two so you notice that the states kind of changed order here and the data was the same we run through it and both
Alice and Bob converged to the idempotent operation of the other person without having to communicate to each
other about the operation they have to they have to transmit the data but it doesn't matter the order that they apply
it in and they magically show up at well magic it's just like I don't know 40
lines of switch statements yeah just not too complicated um so the next one is so
a to what if there's no difference between the data they run it through and yeah nothing changes it converges so and
then the next one is you have data a state two and then data B state two so now it's a it's the states are the same
the vectors are the same but the data is different so most systems out here fail
at this test so if you were to naively apply time stamps or if you were to naively apply a
lot of lamb pores work with vector clocks is they kind of get around conflict but when the states actually
have the exact same matching numbers it doesn't know what to do and in our case
that actually does know what to do we do converge the data B state to data be
state - that's it seems like on I'm a
double check on state - YES on this one they both converge I know that sounds so
trivial but like for whatever reason in a hundred years of computer science nobody bothered to actually solve that
problem next such cases states are the same but we have reversed the order on
the data so they both converge to be state truth is probably getting boring at this point we run through another
edge case B and a versus state to state two and then it both converge
independently to the same data structure and what if we have an attacker so we
have Alice and Bob and Carl Carl's that state nine and nine is actually larger
than a vector that significantly larger than the vectors that the other machines
are already at it doesn't matter if Carl so this is effectively the time stamp
attack or if I set my local clock to two years in the future and using time stamp to resolve data then that the largest
time stamp is always going to win which is terrible then people just keep on putting their clocks higher higher higher this system is not vulnerable to
that attack you see that Alice and Bob do wind up staying at their converged state and Carl's kind of left as a
pitiful terrible you know attacker that doesn't win anything all right
so if a sake of time obviously there's a ton of questions if not I've spent 45 minutes in talk out in Berlin with cow
Kings Barry and the Redis author and a couple other people Cal Kings Boreas
Jepsen tests explaining the system so that would be a whole long talk itself trying to squeeze it in and I'm already
way over time so sooner to tease way cool I want you to walk away with this mind-blowing realization that's that
that might not be it looks so simple but this gives us determine mystic eventually consistent systems
with no extra coordination no powerpuffs or or any other fancy algorithm that
people might come up with so you're our people using sturdy T's I there's a ton
of people that are moving to it now that's there to use a new buzzword I've been working but there was a couple
different the main definition is conflict-free replicated data types obviously that conflict-free the eff is not there so all our variations is
commutative replicated data type which as a mathematician I prefer because the operations are commutative it doesn't matter what order you apply them and
result in the same thing you might also see convergent replicated data types so but conflict-free replicated data type
will pull them up yeah yeah so this is
where I yes so give me two seconds so once we have a conflict resolution
algorithm that can sync data and gives us high-performance deterministic
consensus I don't even want to call it consensus because it's it's just purely deterministic we just have to apply that
to a data strawberry ate a data structure that can be fed into that and that's what gun is graph universe node
it's a graph database and because graphs represent any data structure at a table
or a column store can be is just a matrix in math and a matrix in math is
can be represented as a graph a document or no sequel database documents to screen math and a tree in math present
as a graph but not all graphs can be represented purely as a table or as a document what that means is a graph is a
super structure from that from a data structure standpoint and if graphs can represent all other data structures and
we have a conflict resolution algorithm for it we're actually able to generalize all data now there might be some edge
cases for your business application you have to modify the point thing is that that should be very mind boggling and shattering because you can now you have
a very simple algorithm the very simple data structure that is generalizable to effectively everything ok so why did I
build a graph database well in 1960 with navigation databases they're actually kinda like graph database it's a really awesome but nobody liked them in favor
of doing it the hard way with sequel and in the 1980s they actually tried to create dedicated
hardware so I'm not actually a six but dedicated hardware for sequel a total flop just wound up being that you could
you know do be tree indexes on sequel to get a lot more performance advantages of having hardware's and then we evolved
into oh we love our relational data but all of the managers want to have the relational data spit out as a report so
we're gonna have to map have an object relational mapping such that we can get the object which is the aggregated view
of the data and show that object as effectively a report to our you know our people so everybody got on the Java
bandwagon grace if objects and somebody clever into thousands like document in
the first place well we regretted that and blockchain didn't actually come as a
solution to that problem but you can't think of a blockchain as as a document that's being modified by many different
people and in cryptographically snapshot at at each point so I don't think it's
coincidence that a blockchain is is solving the consistency issues of a
document structure but guaranteeing it like you would expect from a relational database I predict that the future and
I'm biased is not in directed acyclic graphs it's just in flat-out graphs and
the reason why is because directed acyclic graphs are still effectively an
append-only structure so think of all the code that you write and you're using would get probably for most of it or for
smarter people material if the rust implementation of material for the
really smart people I still use kit I'm one of those poor pathetic people I don't like it but it has to store the
entire history you'll wind up trying to rebase we have to make sure that all our peers would agree with rebase blah blah blah blah a directed acyclic graph is
just another way to say an append-only log and append only logs do not scale the end of the day when you're doing hundreds of terabytes of traffic of
Khitan photos and random youtube videos that people are watching because if
we're keeping hundreds of terabytes of traffic every single second and thrown into some blockchain over all of time
know at some point need to clean up you need to get rid of that garbage you need to let the person's face
profile that they can drag and drop and put in a new profile photo and not
mutate their previous data the consumers want that type of experience sure you can also store the history if you want
but the peer-to-peer algorithms should not depend upon the limitations of an
immutable append oh and this is very controversial because everybody's been on a mutable craze but but if you are
able to do as largely because the only way to solve a lot of peer-to-peer problems is by throwing immutable at it
so immutable became popular because it allowed for a lot of decentralized tech to exist but that's not scalable as
probably reason why these problems so if you're able to come up with a peer-to-peer algorithm that allows for immutable data you've you've in one fell
swoop solve so many of these issues so not DAGs tags are great but they still
have the fundamental problem any of them is just graphs just mutable graphs okay
but what is that C thing so C is an almost block chain I started showing up
here but I want to show what was underneath stuff from before if you if
you have a mutable data structure how do you put the graphically verify all this so C is a almost block chain because we
can have a cryptographically linked graph that is owned by user is owned by
public key pair okay so that means the person who owns this user graph is able
to mutate anything in that graph but it's still cryptographically secure can still be verified fully peer-to-peer in
decentralized is that does that make sense so you get the best components of
the cryptography side with users being able to modify their data and then it's
fairly trivial to just intertwine several different users data to produce
the results that you want and more importantly on that component is if the
users are able to mutate that you're able to get all the efficiency advantages on top of course you can also
have an audit log if you want but but like that solves some of the problems and then call out to Marty again who's
working on decentralized identity one the most dangerous problems of this approach is ax doesn't have this problem
but just this problem right here of decentralized cryptographically secure user graphs is you could have a simple
attack right you could have somebody that creates a million Cooper graph this here user accounts and tries to use that
to spam systems Marty with his identity system has been able to confirm the
research by scientists on the Kevin Bacon effect that supposedly within six
or five degrees of separation you're connected to everybody in the world he ran his identify system across he
mined a bunch of Bitcoin miner data and Bitcoin wallets and he ran this with
identify as peer-to-peer identity system and he wound up seeing that there was a
sharp fall off after five degrees of connectivity of peer-to-peer
relationships that after five degrees he could isolate like thousands and thousands of public keys that were
effectively a botnet you all have to come back and talk at some point so so even that problem at this layer is
solved right ugly clothes my reminder I'm I'm gonna have to skip this for
timing sake it's already over time from the fifteen minutes I was just going to show you how the user login system I can
explain it really good two minutes I mean I I can't do it in two minutes
but again cryptography is easy it's just a lot of people in the blockchain world
that have made it hard by trying to run decentralized networks to simulate
centralized behavior you're fighting physics at that point you're creating systems that are fundamentally not scalable what are people thinking all
right so that's how it works okay let me
scroll up it's not gonna go line by line but all right we generate our key pair
we then have an alias of Alice so that's your user name you have the passphrase hopefully better than secret that should
be banned you have a salt and whatever your knots you want should be safer than that you then take the pbkdf2 extension
of the combination of the alias and the salt you could do it pass phrase I don't
recommend that or at least the internet didn't recommend that but so use the nonce use the salt instead because it's
more secure point being is you could directly do this you create a proof-of-work pbkdf2 extension graphic
algorithm you then take the proof that's a result of that work and encrypt your
key pair with that proof with a symmetric algorithm like a yes and our case we're using a s 256 specifically I
want to say don't do this with your Bitcoin wallet but for pretty much all social media content pretty good and
then Marty system is able to deal with hide rocks and stuff like that so now it
prints out the the public key is before up there which is the first console log the second one is the encrypted version
of your keys and then we're going to attempt to login we take the username and pass phrase we create more work so
this prevents brute-force attacks by attackers we then use that login which is the proof of work as the decrypted
the AES decryption key to pull your keys back out and now you have logged back in so ladies and gentlemen you don't don't
don't leave it to civic or some blockchain system or aetherium to have
these using a system like literally in just what seven lines of simple
cryptography you've solved multi-user multi device cryptographically secure
login and if I were to show you the rest of the demo except for the batteries down here we're even able to do password
resets with this mechanism without a server so I figured my password on that
doesn't help oh okay so it's safe so I
just changed my password there and that's because but the password is an
alias you do not derive the keys from your passphrase you just associate the passphrase with it and then we have also
a password reset mechanism it's not too good there's actually some better ones out there but it was simple dammit alright so that was hopefully lost in two
minutes oh that was three minutes and
so that if you were curious the demo I showed at the beginning no there's no hand waving I'm doing with having a
central server you can actually have regular user base logins yet be fully peer-to-peer and cryptographic though
secure yes oh wait the the key is
technically just flat-out ECDSA a key right in this specific case could be RSA or whatever else you want on so it's
just independently generated there is it so it's actually cryptographically safe there's other people who are producing
private keys based off of like pass phrases and that's ridiculous because
then the user can't even it correct yes yes so that problem does not exist with
our system oh wait ugly slide rad it's just our storage engine it's and
we're still working on it daisy chain ad hoc mesh networking this is from a networking layer and again I'm
not gonna go over the algorithm of RAD I'm not gonna go over the algorithm of damn that's a separate discussion what yes let me go up to this so we've
built from here all the way up to about here half way into acts done because
it's so fundamental yeah well actually I should say I'm maintaining done the most
however the most bugs exist in Dan and rad that were or sorry in C in rad that
we're fixing and yes we are hiring and we'd love people to help offload all
this also cryptography stuff so if you feel engineers people who are really
good with storage engines right now and then also people are really good with having creative applications of
cryptography so applied cryptographers not watching sure helps but I don't want
you to come into office and be like oh well we should solve this through Pao or poss cuz I'll just be like tau know like
you know connect the strip pow I'm not abusive I'm not abusive
right Daisy I mean you can ask the other employees to make its to verify yes and
so I'm not really gonna cover that stuff that's just the peer-to-peer protocol underneath and then as you saw the acts
I was gonna do another quick demo and 50 lines of code you could build a very simple peer-to-peer Twitter we're gonna
skip that again I want to come back to this point that these pipe dreams of
DAPs can be done today not not tomorrow
not later so when to launch it'd be really great since we're at that layer to have
engineers that come in and help out one of the biggest problems is making sure that we have enough of the stupid web RTC workarounds a.k servers that we can
relay data through so if you could help us launch some axe peers yourself or you can be very early on in the network and
contribute to providing free bandwidth to people that then later"